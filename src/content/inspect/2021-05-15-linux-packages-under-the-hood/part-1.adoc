
[[sect-part1]]
== How to create a package manually

Linux packages are commonly available in a `.deb` and a `.rpm` file.

* The `.deb` files are meant for distributions of Linux that derive from Debian (Ubuntu, Linux Mint, etc.).
* The `.rpm` files are used primarily by distributions that derive from Redhat based distros (Fedora, CentOS, RHEL).

[NOTE]
.Why two formats?
====
Because there are two main Linux distributions: Red Hat and Debian and each one has its own file formats: `.rpm` for Red Hat Package Manager and `.deb` for Debian.

Both package formats have a lot in common and we will only discuss Debian packages in this document. The following table summarizes the main differences between the archive files.

[cols="<,^,^"]
|===
|| .rpm | .deb

| Archive Format
| Uses the link:https://en.wikipedia.org/wiki/Cpio[`cpio` command and file format].
| Uses the link:https://en.wikipedia.org/wiki/Ar_(Unix)[`ar` command and file format].

| Package Manager
| `rpm` +
(1997, Written in C)
| `dpkg` +
(1993, Written in C)

| Frontend Package Manager
| `yum` +
(2011, Written in Python)
| `apt` +
(1999, Written in C++)

| Database
| `/var/lib/rpm`
| `/var/lib/dpkg`

| Database Format
| Berkeley DB files
| DEB 822 flat files
|===
====

A package is a collection of files to distribute applications or libraries via the Debian package management system. The aim of packaging is to allow the automation of installing, upgrading, configuring, and removing computer programs in a consistent manner.

[[wynk-debian-package-format]]
[NOTE]
.What You Need to Know About the Debian Package Format
====
A `.deb` file is an `ar` archive. The `ar` command is an ancestor of the common `tar` command and was already present in the first Unix version in 1971! Now, this command is (mostly) only used by Debian packages. This archive contains 3 files:

* `debian-binary`: A text file containing `2.0\n`. This states the version of the deb file format. For 2.0, all other lines get ignored.
* `data.tar.gz`: A `tar` archive containing all files that will be installed with their destination paths
[source]
----
./
./sbin/
./sbin/parted
./usr/
./usr/share/
./usr/share/man/
./usr/share/man/man8/
./usr/share/man/man8/parted.8.gz
./usr/share/doc/
./usr/share/doc/parted/
./usr/share/doc/parted/README.Debian
./usr/share/doc/parted/copyright
./usr/share/doc/parted/changelog.Debian.gz
./usr/share/doc/parted/changelog.gz
----
* `control.tar.gz`: A `tar` archive containing various files useful for the `dpkg` command to do its job: metadata about the package (`control`) including the list of required dependencies, the md5 sums of every data file to check integrity (`md5sums`), and also maintainer scripts (ex: `postinst` for post-installation, `prerm` for pre-removal, etc.), which are executables that must be run when installing or removing a package.
[source]
----
control
md5sums
postinst
prerm
----

_Further documentation_:

* link:https://raphaelhertzog.com/2010/11/08/5-reasons-why-a-debian-package-is-more-than-a-simple-file-archive/[5 reasons why a Debian package is more than a simple file archive, RaphaÃ«l Hertzog]
* link:https://www.debian.org/doc/manuals/maint-guide/[Debian New Maintainers' Guide], the official procedure to create a package the "Debian way".
====

You can also learn more about Debian packages by installing a Debian package ðŸ˜€ (the PDF is also available link:https://www.debian.org/doc/manuals/packaging-tutorial/packaging-tutorial.en.pdf[online]):

[source]
----
$ apt install packaging-tutorial
# Check /usr/share/doc/packaging-tutorial/packaging-tutorial.pdf
----

[[wynk-dpkg]]
[NOTE]
.What You Need to Know About the Command `dpkg`
====
The project Dpkg started in 1994, at the same time the Debian package format was created, and thus the command `dpkg` works only with `.deb` binary archives. You must provide the archive as the command does not know how to retrieve it by itself. The command manages a database stored under `/var/lib/dpkg` to keep note of everything that is installed on the server, which is essential to determine what to clean when you remove a package.

Note that the command `dpkg --build` redirects to the command `dpkg-deb --build` and the command `dpkg --list` redirects to the command `dpkg-query --list`. The code of these commands is present in the same repository in `./dpkg-deb/` and `./src/querycmd.c` respectively.

* Official Repository: https://git.dpkg.org/cgit/dpkg/dpkg.git
* GitHub Mirror: https://github.com/guillemj/dpkg
====


To illustrate this post, we will use the Hello World example present in the link:https://gobyexample.com/hello-world[Go by example tutorial].

[source,sh]
----
$ cat > hello.go << HERE
package main
import "fmt"
func main() {
    fmt.Println("hello world")
}
HERE
$ go run hello.go
hello world
$ env GOOS=linux GOARCH=amd64 go build hello.go # Make sure to build for Linux
$ ls
hello    hello.go
$ chmod +x hello
$ ./hello
hello world
----

Our goal is to package this binary and the most popular solution to build a Debian package for a Go program is the link:https://go-team.pages.debian.net/packaging.html[utility `dh-golang`]. As we want to use the most basic commands to get as close as possible to the process, we will use the standard `dpkg` command even if that means not building a world-class Debian package.


=== Prerequisites

To test the packages we are going to build and install, we will use a Debian VM in order to keep your system safe. We will use link:https://www.vagrantup.com/[Vagrant] to create this server. Make sure Vagrant is installed on your system by following the link:https://learn.hashicorp.com/tutorials/vagrant/getting-started-install?in=vagrant/getting-started[installation procedure] for your operating system.

NOTE: There is a companion GitHub repository link:https://github.com/julien-sobczak/linux-packages-under-the-hood[julien-sobczak/linux-packages-under-the-hood] to this blog post. This repository is optional for this article. It mostly contains a `Vagrantfile` to start the virtual machine, the files to create various Debian versions of the package `hello`, and also the Go code that reimplements minimal versions of the `dpkg` and `apt` commands. You will find more information in the link:https://github.com/julien-sobczak/linux-packages-under-the-hood/blob/master/README.md[`README.md`] file of this repository.

Then:

[source, sh]
----
$ mkdir sandbox
$ cd sandbox
$ vagrant init
$ echo > Vagranfile <<EOF
# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.configure("2") do |config|
  config.vm.box = "debian/buster64"
end
EOF
$ vagrant up
# wait a few minutes
$ vagrant ssh
vagrant$ uname -a
Linux buster 4.19.0-16-amd64 #1 SMP Debian 4.19.181-1 (2021-03-19) x86_64 GNU/Linux
----

When using Vagrant, the directory containing your `Vagrantfile` is accessible from the virtual machine from the directory `/vagrant`. We will use it to copy our `hello` binary program:

[source,sh]
----
$ ls
Vagrantfile
$ cp /path/to/hello .
$ vagrant ssh
vagrant$ cd /vagrant
vagrant$ ls
hello Vagrantfile
----

NOTE: All commands whose prompt starts with `vagrant#` must be run inside the virtual machine. Otherwise, run the commands from your host.

We are ready to create a Debian package for our Hello program.

[source,sh]
----
vagrant# cd /vagrant/
vagrant# mkdir -p ./debian/usr/bin # <1>
vagrant# cp hello ./debian/usr/bin/
vagrant# mkdir -p ./debian/DEBIAN # <1>
vagrant# cat > ./debian/DEBIAN/control <<EOF
Package: hello
Version: 1.1-1
Section: base
Priority: optional
Architecture: amd64
Maintainer: Julien Sobczak
Description: Say Hello
EOF
vagrant# cat > ./debian/DEBIAN/preinst <<EOF # <2>
#!/bin/sh
echo "preinst says hello";
EOF
vagrant# cat > ./debian/DEBIAN/postinst <<EOF # <2>
#!/bin/sh
echo "postinst says hello";
EOF
vagrant# tree /vagrant/debian/
|-- DEBIAN
|   |-- control
|   |-- preinst
|   `-- postinst
`-- usr
    `-- bin
        `-- hello
----
<1> The first version of our package `hello` contains only the binary `hello` built previously and a DEB822 file `control` with the package metadata.
<2> We also append basic maintainer scripts that displays a message in the console so that we will know when the installation process runs them.


[[wynk-deb822]]
[NOTE]
.What You Need to Know About the DEB822 Format
====
This format can be seen as an ancestor of YAML or JSON. Here is an example showing the three supported types of fields:

[source,deb822]
----
FieldSimple: simple value
FieldFolded: very long value
 continuing on the next line starting with a space.
FieldMultiline:
 /usr/bin/cmd1
 /usr/bin/cmd2
----

The format is used by the file `control` but also by some files in the `dpkg` database such as `/var/lib/dpkg/status`. This format is also used by the command `apt`, which will be covered later.

_Further documentation_: Check the link:https://man7.org/linux/man-pages/man5/deb822.5.html[man page] for additional information.
====

[[cmd-dpkg-build]]
=== `dpkg --build`

We will use the command `dpkg --build` to build our package:

[source,sh]
----
$ apt install fakeroot # install the fakeroot command
$ fakeroot dpkg --build debian hello_1.1-1_amd64.deb # <1>
----
<1> This command builds a Debian package, which as outlined before, consists in building an `ar` archive containing two `tar` archives: the content of our directory `DEBIAN/` in `control.tar.gz` and the other files in `data.tar.gz`. We use the `fakeroot` command to make sure files inside the archive are created with the user `root`.

We can also reproduce its working link:https://unix.stackexchange.com/questions/30303/how-to-create-a-deb-file-manually[using standard Bash commands]:

[source,sh]
----
$ apt install binutils # install the ar command
$ apt install fakeroot # install the fakeroot command
$ echo 2.0 > debian-binary
$ cd debian && tar czf ../data.tar.gz [a-z]* && cd ..
$ cd debian/DEBIAN/ && tar czf ../../control.tar.gz * && cd ../..
$ fakeroot ar r hello_1.1-1_amd64.deb debian-binary control.tar.gz data.tar.gz
ar: creating hello_1.1-1_amd64.deb # <1>
----
<1> The package will fail most linter checks. Indeed, we ignored many of the best practices that higher-level commands ensure but we will still be able to install this package on our server.

Now is the time to look at the code. Dpkg is written in C, and the function executed by the command `dpkg --build` is the link:https://github.com/guillemj/dpkg/blob/1.20.7/dpkg-deb/build.c#L552-L728[function `do_build` in `./dpkg-deb/build.c`].

.dpkg-deb/build.c
[source, c]
----
int
do_build(const char *const *argv)
{
  struct compress_params control_compress_params;
  struct tar_pack_options tar_options;
  struct dpkg_error err;
  struct dpkg_ar *ar;
  const char *dir, *dest;
  char *ctrldir;
  char *debar;
  char *tfbuf;
  int gzfd;

  /* Decode our arguments. */
  dir = *argv++;
  dest = *argv++;

  debar = gen_dest_pathname(dir, dest); // <1>
  ctrldir = str_fmt("%s/%s", dir, "DEBIAN");

  /* Now that we have verified everything it is time to actually
   * build something. Let's start by making the ar-wrapper. */
  ar = dpkg_ar_create(debar, 0644); // <2>

  /* Create a temporary file to store the control data in. */
  tfbuf = path_make_temp_template("dpkg-deb");
  gzfd = mkstemp(tfbuf);
  free(tfbuf);

  /* Select the compressor to use for our control archive. */
  control_compress_params.type = COMPRESSOR_TYPE_GZIP;
  control_compress_params.strategy = COMPRESSOR_STRATEGY_NONE;
  control_compress_params.level = -1;

  /* Fork a tar to package the control-section of the package. */
  tar_options.mode = "u+rw,go=rX";
  tar_options.root_owner_group = true;
  tarball_pack(ctrldir, control_treewalk_feed, &tar_options,
               &control_compress_params, gzfd);

  free(ctrldir);

  /* We have our first file for the ar-archive. Write a header for it
   * to the package and insert it. */
  const char deb_magic[] = "2.0\n";
  char adminmember[16 + 1];

  sprintf(adminmember, "%s%s", "control.tar",
          compressor_get_extension(control_compress_params.type));

  dpkg_ar_put_magic(ar); // <3>
  dpkg_ar_member_put_mem(ar, "debian-binary", deb_magic, strlen(deb_magic)); // <4>
  dpkg_ar_member_put_file(ar, adminmember, gzfd, -1); // <5>

  close(gzfd);

  /* Control is done, now we need to archive the data. */

  /* Start by creating a new temporary file. */
  tfbuf = path_make_temp_template("dpkg-deb");
  gzfd = mkstemp(tfbuf);
  free(tfbuf);

  /* Pack the directory into a tarball, feeding files from the callback. */
  tar_options.mode = NULL;
  tar_options.root_owner_group = opt_root_owner_group;
  tarball_pack(dir, file_treewalk_feed, &tar_options, &compress_params, gzfd);

  /* Okay, we have data.tar as well now, add it to the ar wrapper. */
  char datamember[16 + 1];

  sprintf(datamember, "%s%s", "data.tar",
          compressor_get_extension(compress_params.type));

  dpkg_ar_member_put_file(ar, datamember, gzfd, -1); // <6>

  close(gzfd);

  if (fsync(ar->fd))
    ohshite(_("unable to sync file '%s'"), ar->name);

  dpkg_ar_close(ar); // <7>

  free(debar);

  return 0;
}
----
<1> The variable `dir` is the local directory containing the package files to build. The variable `dest` is the optional filename for the final package file and `debar` is the final name as determined by the function `gen_dest_pathname`, which determines a default name if the argument is missing.
<2> The function `dpkg_ar_create` creates the archive file named after the variable `debar`.
<3> The function `dpkg_ar_put_magic` defines the magic number `!<arch>\n` telling Linux the file is of type `ar`.
<4> The function `dpkg_ar_member_put_mem` appends the file `debian-binary` with the content of the variable `deb_magic`.
<5> The function `dpkg_ar_member_put_file` appends the file `control.tar` with the content of a temporary file.
<6> Same as above for `data.tar`.
<7> The function `dpkg_ar_close` is part of the housecleaning logic and simply closes the file descriptor.

[[sect-part1-go]]
=== Case Study

What follows is a minimal rewrite of this code in Go. The full code is available on GitHub in the repository link:https://github.com/julien-sobczak/linux-packages-under-the-hood[julien-sobczak/linux-packages-under-the-hood].

[source,go]
.cmd/dpkg/main.go
----
include::./dpkg_build.go[]
----

To run the code:

[source, sh]
----
$ go run main.go hello hello.deb
----

To inspect the resulting archive `hello.deb`, we can use the command `dpkg -c` to view the data files or use the command `ar` to view the real content of the archive:

[source, sh]
----
vagrant# dpkg -c /vagrant/hello.deb
-rw-r-x--- 0/0         2034781 1970-01-01 00:00 usr/bin/hello

vagrant# ar -tf /vagrant/hello.deb
ar -tf /vagrant/hello.deb
debian-binary
control.tar
data.tar
vagrant# ar -xf /vagrant/hello.deb data.tar
vagrant# tar -tf data.tar
usr/bin/hello
----

ðŸŽ‰ *We have finished with the format `.deb`.* This completes the first part of this article. We created a Debian package from scratch! Now, we will inspect the installation process.


